---
title: 'Assignment 2: Nonlinear Dimensionality Reduction'
author: "Gonzalo Solera, Zofia Tarant"
date: "6 01 2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Dataset
```{r generate dataset}
t <- seq(-1.5*pi,1.5*pi,l=100)
R<- 1
n<-75
sd.eps <- .15

set.seed(1)
y <- R*sign(t) - R*sign(t)*cos(t/R)
x <- -R*sin(t/R)
z <- (y/(2*R))^2
rt <- sort(runif(n)*3*pi - 1.5*pi)
eps <- rnorm(n)*sd.eps
ry <- R*sign(rt) - (R+eps)*sign(rt)*cos(rt/R)
rx <- -(R+eps)*sin(rt/R)
rz <- (ry/(2*R))^2 + runif(n,min=-2*sd.eps,max=2*sd.eps)
XYZ <- cbind(rx,ry,rz)

distXYZ <- dist(XYZ)

require(plot3D)
lines3D(x,y,z,colvar = NULL, 
         phi = 20, theta = 60, r =sqrt(3), d =3, scale=FALSE,
         col=2,lwd=4,as=1,
         xlim=range(rx),ylim=range(ry),zlim=range(rz))
points3D(rx,ry,rz,col=4,pch=19,cex=.6,add=TRUE)
```

Q1. Write a function that computes MadjK′ as a function of two distance matrices between points (one being computed in the high-dimensional space, an the other being the Euclidean distance matrix in the low-dimensional configuration) and the value K′.

```{r Q1}
library(smacof)
common.neighbors <- function(D, X, K_) {
  wD <- as.matrix(dissWeights(D, type = "knn", k = K_))
  wX <- as.matrix(dissWeights(X, type = "knn", k = K_))
  rowSums(wD & wX)
}

calculate.M.K_ <- function(D, X, K_) {
  N.K_ = mean(common.neighbors(D,X,K_))

  N.K_/K_
}
calculate.adj.M.K_ <- function(D, X, K_) {
  # D - high dim. matrix
  # X - euclidean distance matrix
  M.K_ <- calculate.M.K_(D, X, K_)
  M.K_-K_/(n-1)
}

```

Q2. Choose the pair (K,τ) maximizing the Local Continuity Meta-criteria. 

Looking for optimal K, tau according to the paper by the Chen and Buja paper from 2009 referenced in the Assignment description.

```{r Q2}

Stress.LocalMDS <- function(conf,n,dist.orig,k=5,tau=1){
  require(smacof)
  q<-1
  mconf <- matrix(conf,nrow = n, byrow = FALSE) # configuration matrix
  Eucl.dist <- dist(mconf)
  w <- dissWeights(dist.orig, type = "knn", k = k)
  w.1 <- (w==1)
  card.N.k <- sum(w.1)
  card.N.k.c <- n*(n-1)/2 - card.N.k
  t <- (card.N.k/card.N.k.c)*median(dist.orig[w.1])*tau
  return(sum((dist.orig[w.1]-Eucl.dist[w.1])^2) - t*sum(Eucl.dist[!w.1]))
}
conf0 <- as.numeric(cmdscale(distXYZ))

K.search <- c(5,10,15)
tau.search <- c(.1, .5, 1)
best_M.K_ <- NULL
for(K in K.search) {
  for(tau in tau.search) {
    localMDS.S.res <- optim(par=conf0, fn=Stress.LocalMDS, n=n, dist.orig=distXYZ, k=K, tau=tau, method ="BFGS", control = list(maxit=20))
    conf.localMDS.S.res <- matrix(localMDS.S.res$par, nrow = n, byrow = FALSE)
    
    K_ <- 10
    M.K_ <- calculate.adj.M.K_(distXYZ, dist(conf.localMDS.S.res), K_)
    print(M.K_)
    if(is.null(best_M.K_) || best_M.K_ < M.K_) {
      best_M.K_ <- M.K_
      best_K <- K
      best_tau <- tau
      best_conf <- conf.localMDS.S.res
    }
  }
}

print("Best K:")
print(best_K)
print("Best tau:")
print(best_tau)

```
```{r}
```



Q3. Graphical representation of the Local MDS output For the optimal K and τ, the output of the Local MDS is a q-dimensional configuration, that is, a n×q matrix (in our case with q=1).
```{r}
# Here we need to use q somehow:
pairs(cbind(XYZ,rt,locMDS=best_conf[,1]))
```



Q4. Choose the parameter k maximizing the Local Continuity Meta-criteria.
Use K′=10 and restrict the search of k to seq(4,15).

Do a plot of the pairs (k,LC(k)) and write the optimal value of k.
```{r}
k.search.range <- seq(4,15)
K <- 10
LC <- map(K.search.range, function(kk) calculate.adj.M.K(D=distXYZ, X=Eucl.dist, K=kk))
plot(K.search, LC )
```
Q5. Graphical representation of the ISOMAP output

For the optimal K, the output of the vegan::isomap is an isomap object which element points is the found q-dimensional configuration, that is, it is a n×q matrix (in our case with q=1). 


```{r}
k <- 10
q <- 1
# how to find k?
library(vegan)
isomap.max <- vegan::isomap(distXYZ, k=10, q=q)
pairs(cbind(XYZ,rt,isomap=isomap.max$points[,1]))
```


Q6. Choose the parameter perplexity maximizing the Local Continuity Meta-criteria.

Use K′=10 and restrict the search of perplexity to seq(9,21,by=3).

Do a plot of the pairs (perplexity,LC(perplexity)) and write the optimal value of perplexity.

```{r}
library(tsne)

```


Q7. Graphical representation of the t-SNE output.

For the optimal perplexity, the output of the Rtsne::Rtsne is a list of elements, one of them called Y contains the desired q-dimensional configuration, that is, it is a n×q matrix (in our case with q=1). Call Rtsne.max to this output and represent it using the following instruction:

pairs(cbind(XYZ,rt,tSNE=Rtsne.max$Y[,1]))

Q8. Compare graphically the results of the different techniques.

```{r}
pairs(cbind(rt,locMDS=LocalMDS.max[,1], 
            isomap=isomap.max$points[,1],  
            tSNE=Rtsne.max$Y[,1]))

```


